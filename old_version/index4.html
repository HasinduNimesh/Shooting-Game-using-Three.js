<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js FPS Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        
        #game-container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 16px;
            text-shadow: 2px 2px 2px rgba(0, 0, 0, 0.5);
            pointer-events: none;
            user-select: none;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            user-select: none;
        }
        
        #crosshair::before, #crosshair::after {
            content: "";
            position: absolute;
            background-color: rgba(255, 255, 255, 0.7);
        }
        
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
            top: 0;
        }
        
        #crosshair::after {
            width: 20px;
            height: 2px;
            left: 0;
            top: 9px;
        }
        
        #health-bar {
            width: 200px;
            height: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid #fff;
            margin-bottom: 10px;
        }
        
        #health-fill {
            width: 100%;
            height: 100%;
            background-color: #f00;
            transition: width 0.3s;
        }
        
        #ammo-bar {
            width: 150px;
            height: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid #fff;
            margin-bottom: 10px;
        }
        
        #ammo-fill {
            width: 100%;
            height: 100%;
            background-color: #ffaa00;
            transition: width 0.3s;
        }
        
        #score {
            font-size: 24px;
            margin-top: 10px;
        }
        
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-size: 36px;
            display: none;
        }
        
        #restart-button {
            margin-top: 30px;
            padding: 15px 30px;
            background-color: #f00;
            color: #fff;
            border: none;
            font-size: 24px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        #restart-button:hover {
            background-color: #ff3333;
        }
        
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
        }
        
        #start-screen h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #f00;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }
        
        #start-screen p {
            font-size: 18px;
            margin-bottom: 40px;
            max-width: 600px;
            text-align: center;
            line-height: 1.5;
        }
        
        #start-button {
            padding: 15px 30px;
            background-color: #f00;
            color: #fff;
            border: none;
            font-size: 24px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        #start-button:hover {
            background-color: #ff3333;
        }
        
        #instructions {
            margin-top: 30px;
            font-size: 16px;
            max-width: 600px;
            text-align: center;
        }
        
        .key {
            display: inline-block;
            background-color: #333;
            padding: 5px 10px;
            border-radius: 5px;
            margin: 0 5px;
        }
        
        #damage-indicator {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            border: 0px solid rgba(255, 0, 0, 0.5);
            box-sizing: border-box;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .muzzle-flash {
            position: absolute;
            width: 100px;
            height: 100px;
            top: 60%;
            left: 50%;
            transform: translate(-50%, 0);
            background: radial-gradient(circle, rgba(255,255,0,0.8) 0%, rgba(255,165,0,0.5) 50%, rgba(255,0,0,0) 100%);
            border-radius: 50%;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.05s;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    
    <div id="hud">
        <div id="health-bar"><div id="health-fill"></div></div>
        <div id="ammo-bar"><div id="ammo-fill"></div></div>
        <div id="ammo-text">Ammo: 30/90</div>
        <div id="score">Score: 0</div>
    </div>
    
    <div id="crosshair"></div>
    <div id="damage-indicator"></div>
    <div class="muzzle-flash"></div>
    
    <div id="game-over">
        <div>Game Over</div>
        <div id="final-score">Final Score: 0</div>
        <button id="restart-button">Restart</button>
    </div>
    
    <div id="start-screen">
        <h1>CUBE SHOOTER</h1>
        <p>Survive waves of enemy cubes in this first-person shooter. Eliminate enemies to score points and collect ammo from their remains.</p>
        <button id="start-button">Start Game</button>
        <div id="instructions">
            <p><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> to move</p>
            <p><span class="key">Mouse</span> to aim</p>
            <p><span class="key">Left Click</span> to shoot</p>
            <p><span class="key">R</span> to reload</p>
            <p><span class="key">Shift</span> to sprint</p>
        </div>
    </div>
    
    <!-- Import Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
    // Game state
    const gameState = {
        started: false,
        active: false,
        paused: false,
        over: false,
        score: 0,
        wave: 1,
        enemiesKilled: 0,
        health: 100,
        maxHealth: 100,
        ammo: 30,
        maxAmmo: 30,
        reserveAmmo: 90,
        maxReserveAmmo: 120,
        reloading: false
    };
    
    // Game settings
    const settings = {
        enemySpeed: 0.5,
        enemyDamage: 10,
        playerSpeed: 0.1,
        sprintMultiplier: 1.8,
        gunDamage: 25,
        reloadTime: 2000,
        enemiesPerWave: 5,
        enemySpawnDistance: 50
    };
    
    // Initialize Three.js
    let camera, scene, renderer;
    let controls, raycaster, mouse;
    let player, weapon, enemies = [], bullets = [], pickups = [];
    
    // Player movement variables
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    let moveForward = false;
    let moveBackward = false;
    let moveLeft = false;
    let moveRight = false;
    let canJump = false;
    let sprinting = false;
    let prevTime = performance.now();
    
    // DOM elements
    const healthFill = document.getElementById('health-fill');
    const ammoFill = document.getElementById('ammo-fill');
    const ammoText = document.getElementById('ammo-text');
    const scoreText = document.getElementById('score');
    const gameOverScreen = document.getElementById('game-over');
    const finalScoreText = document.getElementById('final-score');
    const restartButton = document.getElementById('restart-button');
    const startScreen = document.getElementById('start-screen');
    const startButton = document.getElementById('start-button');
    const damageIndicator = document.getElementById('damage-indicator');
    const muzzleFlash = document.querySelector('.muzzle-flash');
    
    // Start Button Event Listener
    startButton.addEventListener('click', function() {
        startScreen.style.display = 'none';
        initGame();
    });
    
    // Restart Button Event Listener
    restartButton.addEventListener('click', function() {
        gameOverScreen.style.display = 'none';
        resetGame();
    });
    
    function initGame() {
        // Initialize Three.js scene
        initScene();
        
        // Create level environment
        createEnvironment();
        
        // Create player
        createPlayer();
        
        // Create weapon
        createWeapon();
        
        // Initialize controls
        initControls();
        
        // Set up event listeners
        setupEventListeners();
        
        // Start game loop
        gameState.started = true;
        gameState.active = true;
        
        // Start first wave
        spawnEnemyWave();
        
        // Start animation loop
        animate();
    }
    
    function initScene() {
        // Create scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb); // Sky blue
        scene.fog = new THREE.Fog(0x87ceeb, 0, 100);
        
        // Create camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.y = 1.6; // Player height
        
        // Create renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('game-container').appendChild(renderer.domElement);
        
        // Add lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(1, 1, 1);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        scene.add(directionalLight);
        
        // Initialize raycaster for shooting
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();
    }
    
    function createEnvironment() {
        // Create floor
        const floorGeometry = new THREE.PlaneGeometry(200, 200);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x666666,
            roughness: 0.8,
            metalness: 0.2
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);
        
        // Create boundary walls
        const wallHeight = 5;
        const wallMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x888888,
            roughness: 0.7,
            metalness: 0.1
        });
        
        // North wall
        const northWallGeometry = new THREE.BoxGeometry(200, wallHeight, 1);
        const northWall = new THREE.Mesh(northWallGeometry, wallMaterial);
        northWall.position.set(0, wallHeight/2, -100);
        northWall.castShadow = true;
        northWall.receiveShadow = true;
        scene.add(northWall);
        
        // South wall
        const southWall = northWall.clone();
        southWall.position.z = 100;
        scene.add(southWall);
        
        // East wall
        const eastWallGeometry = new THREE.BoxGeometry(1, wallHeight, 200);
        const eastWall = new THREE.Mesh(eastWallGeometry, wallMaterial);
        eastWall.position.set(100, wallHeight/2, 0);
        eastWall.castShadow = true;
        eastWall.receiveShadow = true;
        scene.add(eastWall);
        
        // West wall
        const westWall = eastWall.clone();
        westWall.position.x = -100;
        scene.add(westWall);
        
        // Add some obstacles
        const obstacleMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x8b4513, // Brown
            roughness: 0.9,
            metalness: 0.1
        });
        
        for (let i = 0; i < 20; i++) {
            const obstacleSize = 1 + Math.random() * 3;
            const obstacleHeight = 1 + Math.random() * 4;
            const obstacleGeometry = new THREE.BoxGeometry(obstacleSize, obstacleHeight, obstacleSize);
            const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
            
            // Random position within boundaries
            let validPosition = false;
            let x, z;
            
            while (!validPosition) {
                x = (Math.random() - 0.5) * 180;
                z = (Math.random() - 0.5) * 180;
                
                // Check if position is far enough from player start point
                const distFromOrigin = Math.sqrt(x*x + z*z);
                if (distFromOrigin > 10) {
                    validPosition = true;
                }
            }
            
            obstacle.position.set(x, obstacleHeight/2, z);
            obstacle.castShadow = true;
            obstacle.receiveShadow = true;
            obstacle.userData.isObstacle = true;
            scene.add(obstacle);
        }
    }
    
    function createPlayer() {
        // Create player collision body (not visible but used for collisions)
        const playerGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 32);
        const playerMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xff0000,
            visible: false
        });
        player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.position.y = 1; // Half of player height
        scene.add(player);
    }
    
    function createWeapon() {
        // Create weapon group
        weapon = new THREE.Group();
        
        // Create gun body
        const gunBodyGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.5);
        const gunBodyMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
        const gunBody = new THREE.Mesh(gunBodyGeometry, gunBodyMaterial);
        gunBody.position.set(0.3, -0.2, -0.5);
        weapon.add(gunBody);
        
        // Create gun barrel
        const gunBarrelGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.6, 16);
        const gunBarrelMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
        const gunBarrel = new THREE.Mesh(gunBarrelGeometry, gunBarrelMaterial);
        gunBarrel.rotation.x = Math.PI / 2;
        gunBarrel.position.set(0.3, -0.17, -0.75);
        weapon.add(gunBarrel);
        
        // Create gun handle
        const gunHandleGeometry = new THREE.BoxGeometry(0.08, 0.2, 0.1);
        const gunHandleMaterial = new THREE.MeshStandardMaterial({ color: 0x111111 });
        const gunHandle = new THREE.Mesh(gunHandleGeometry, gunHandleMaterial);
        gunHandle.position.set(0.3, -0.3, -0.4);
        weapon.add(gunHandle);
        
        // Add weapon to camera (first-person view)
        camera.add(weapon);
    }
    
    function initControls() {
        // Lock pointer for FPS controls
        document.addEventListener('click', function() {
            if (gameState.active && !gameState.paused) {
                renderer.domElement.requestPointerLock();
            }
        });
        
        // Mouse movement for camera control
        document.addEventListener('mousemove', onMouseMove, false);
        
        // Shooting controls
        document.addEventListener('mousedown', onMouseDown, false);
        
        // Reload control
        document.addEventListener('keydown', function(event) {
            if (event.code === 'KeyR' && gameState.active && !gameState.reloading) {
                reload();
            }
        });
        
        // Sprint control
        document.addEventListener('keydown', function(event) {
            if (event.code === 'ShiftLeft' && gameState.active) {
                sprinting = true;
            }
        });
        
        document.addEventListener('keyup', function(event) {
            if (event.code === 'ShiftLeft') {
                sprinting = false;
            }
        });
    }
    
    function setupEventListeners() {
        // Keyboard controls for movement
        document.addEventListener('keydown', function(event) {
            if (gameState.active && !gameState.paused) {
                switch (event.code) {
                    case 'KeyW':
                        moveForward = true;
                        break;
                    case 'KeyA':
                        moveLeft = true;
                        break;
                    case 'KeyS':
                        moveBackward = true;
                        break;
                    case 'KeyD':
                        moveRight = true;
                        break;
                }
            }
        });
        
        document.addEventListener('keyup', function(event) {
            switch (event.code) {
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'KeyD':
                    moveRight = false;
                    break;
            }
        });
        
        // Handle window resize
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Pointer lock change
        document.addEventListener('pointerlockchange', function() {
            if (document.pointerLockElement === renderer.domElement) {
                // Pointer locked
            } else {
                // Pointer unlocked
                if (gameState.active && !gameState.over) {
                    pauseGame();
                }
            }
        });
    }
    
    function onMouseMove(event) {
        if (document.pointerLockElement === renderer.domElement) {
            // Update camera rotation based on mouse movement
            const movementX = event.movementX || 0;
            const movementY = event.movementY || 0;
            
            // Rotate left/right
            camera.rotation.y -= movementX * 0.002;
            
            // Limit up/down rotation to prevent over-rotation
            const newRotationX = camera.rotation.x - movementY * 0.002;
            if (newRotationX < Math.PI / 2 && newRotationX > -Math.PI / 2) {
                camera.rotation.x = newRotationX;
            }
        }
    }
    
    function onMouseDown(event) {
        if (document.pointerLockElement === renderer.domElement && event.button === 0) {
            // Check if player has ammo
            if (gameState.ammo > 0 && !gameState.reloading) {
                shoot();
            } else if (gameState.ammo === 0 && gameState.reserveAmmo > 0) {
                reload();
            }
        }
    }
    
    function shoot() {
        // Decrease ammo
        gameState.ammo--;
        updateHUD();
        
        // Show muzzle flash
        muzzleFlash.style.opacity = 1;
        setTimeout(() => {
            muzzleFlash.style.opacity = 0;
        }, 50);
        
        // Create bullet trail effect
        const bulletGeometry = new THREE.CylinderGeometry(0.01, 0.01, 1, 8);
        const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
        
        // Position bullet at gun barrel
        bullet.position.copy(camera.position);
        
        // Direction is where the camera is looking
        const direction = new THREE.Vector3();
        camera.getWorldDirection(direction);
        
        // Set bullet rotation to match direction
        const axis = new THREE.Vector3(0, 1, 0);
        bullet.quaternion.setFromUnitVectors(axis, direction);
        bullet.rotation.x += Math.PI / 2;
        
        // Add random spread
        const spread = 0.02;
        direction.x += (Math.random() - 0.5) * spread;
        direction.y += (Math.random() - 0.5) * spread;
        direction.z += (Math.random() - 0.5) * spread;
        direction.normalize();
        
        // Add bullet to scene
        scene.add(bullet);
        
        // Add to bullets array with direction and creation time
        bullets.push({
            mesh: bullet,
            direction: direction,
            distance: 0,
            created: Date.now()
        });
        
        // Check for hits using raycaster
        raycaster.set(camera.position, direction);
        
        // Check intersections with enemies
        const enemyIntersects = raycaster.intersectObjects(
            enemies.map(enemy => enemy.mesh)
        );
        
        if (enemyIntersects.length > 0 && enemyIntersects[0].distance < 50) {
            const hitEnemyMesh = enemyIntersects[0].object;
            const hitEnemy = enemies.find(enemy => enemy.mesh === hitEnemyMesh);
            
            if (hitEnemy) {
                hitEnemy.health -= settings.gunDamage;
                
                // Create hit effect
                createHitEffect(enemyIntersects[0].point);
                
                if (hitEnemy.health <= 0) {
                    // Enemy killed
                    killEnemy(hitEnemy);
                } else {
                    // Enemy hit but not killed
                    // Add visual feedback
                    hitEnemy.mesh.material.color.set(0xff0000);
                    setTimeout(() => {
                        hitEnemy.mesh.material.color.set(hitEnemy.color);
                    }, 100);
                }
            }
        }
        
        // Add recoil effect to weapon
        const recoilAmount = 0.05;
        weapon.position.z += recoilAmount;
        setTimeout(() => {
            weapon.position.z -= recoilAmount;
        }, 50);
    }
    
    function createHitEffect(position) {
        // Create particle effect at hit position
        const particleCount = 10;
        const particleGroup = new THREE.Group();
        
        for (let i = 0; i < particleCount; i++) {
            const particle = new THREE.Mesh(
                new THREE.SphereGeometry(0.05, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            
            // Position at hit point
            particle.position.copy(position);
            
            // Random direction
            const direction = new THREE.Vector3(
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.5) * 2
            );
            direction.normalize();
            
            // Add to group with direction and speed
            particle.userData.direction = direction;
            particle.userData.speed = 0.1 + Math.random() * 0.1;
            particle.userData.created = Date.now();
            
            particleGroup.add(particle);
        }
        
        scene.add(particleGroup);
        
        // Remove after a short time
        setTimeout(() => {
            scene.remove(particleGroup);
        }, 1000);
    }
    
    function reload() {
        if (gameState.reserveAmmo <= 0 || gameState.ammo >= gameState.maxAmmo || gameState.reloading) {
            return;
        }
        
        gameState.reloading = true;
        
        // Animation for weapon during reload
        const reloadSequence = () => {
            // Down
            weapon.position.y -= 0.1;
            setTimeout(() => {
                // Rotate
                weapon.rotation.z = -Math.PI / 8;
                setTimeout(() => {
                    // Back
                    weapon.rotation.z = 0;
                    weapon.position.y += 0.1;
                }, settings.reloadTime / 3);
            }, settings.reloadTime / 3);
        };
        
        reloadSequence();
        
        // Update HUD to show reloading
        ammoText.textContent = "Reloading...";
        
        // Reload after delay
        setTimeout(() => {
            const ammoNeeded = gameState.maxAmmo - gameState.ammo;
            const ammoToAdd = Math.min(ammoNeeded, gameState.reserveAmmo);
            
            gameState.ammo += ammoToAdd;
            gameState.reserveAmmo -= ammoToAdd;
            gameState.reloading = false;
            
            updateHUD();
        }, settings.reloadTime);
    }
    
    function spawnEnemyWave() {
        // Increase enemy count for each wave
        const enemyCount = settings.enemiesPerWave + (gameState.wave - 1) * 2;
        
        for (let i = 0; i < enemyCount; i++) {
            // Delay spawn of each enemy
            setTimeout(() => {
                if (gameState.active) {
                    spawnEnemy();
                }
            }, i * 1000);
        }
        
        // Increase wave counter
        gameState.wave++;
    }
    
    function spawnEnemy() {
        // Calculate spawn position (random point around player)
        const angle = Math.random() * Math.PI * 2;
        const spawnDistance = settings.enemySpawnDistance;
        
        const spawnX = player.position.x + Math.cos(angle) * spawnDistance;
        const spawnZ = player.position.z + Math.sin(angle) * spawnDistance;
        
        // Create enemy
        const enemySize = 1 + Math.random() * 0.5;
        const enemyGeometry = new THREE.BoxGeometry(enemySize, enemySize, enemySize);
        
        // Randomly choose enemy color and health based on size
        let enemyColor, enemyHealth;
        const enemyType = Math.random();
        
        if (enemyType < 0.6) {
            // Regular enemy (red)
            enemyColor = 0xff0000;
            enemyHealth = 50;
        } else if (enemyType < 0.9) {
            // Stronger enemy (purple)
            enemyColor = 0x8800ff;
            enemyHealth = 100;
        } else {
            // Elite enemy (gold)
            enemyColor = 0xffaa00;
            enemyHealth = 200;
        }
        
        const enemyMaterial = new THREE.MeshStandardMaterial({ color: enemyColor });
        const enemyMesh = new THREE.Mesh(enemyGeometry, enemyMaterial);
        
        enemyMesh.position.set(spawnX, enemySize/2, spawnZ);
        enemyMesh.castShadow = true;
        enemyMesh.receiveShadow = true;
        
        scene.add(enemyMesh);
        
        // Add to enemies array
        enemies.push({
            mesh: enemyMesh,
            size: enemySize,
            speed: settings.enemySpeed * (1 - (enemySize - 1) * 0.3), // Larger enemies move slower
            health: enemyHealth,
            maxHealth: enemyHealth,
            color: enemyColor,
            lastAttack: 0
        });
    }
    
    function killEnemy(enemy) {
        // Increase score based on enemy type
        const scoreValue = enemy.maxHealth / 10;
        gameState.score += scoreValue;
        gameState.enemiesKilled++;
        
        // Update HUD
        updateHUD();
        
        // Create explosion effect
        const explosionColor = enemy.color;
        const explosionGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        const explosionMaterial = new THREE.MeshBasicMaterial({ color: explosionColor });
        
        for (let i = 0; i < 20; i++) {
            const explosionPiece = new THREE.Mesh(explosionGeometry, explosionMaterial);
            explosionPiece.position.copy(enemy.mesh.position);
            
            // Random direction
            const direction = new THREE.Vector3(
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.5) * 2
            );
            direction.normalize();
            
            explosionPiece.userData = {
                direction: direction,
                speed: 0.1 + Math.random() * 0.2,
                rotationSpeed: Math.random() * 0.1,
                created: Date.now()
            };
            
            scene.add(explosionPiece);
            
            // Remove after a short time
            setTimeout(() => {
                scene.remove(explosionPiece);
            }, 1000 + Math.random() * 1000);
        }
        
        // Chance to drop ammo pickup
        if (Math.random() < 0.3) {
            createAmmoPickup(enemy.mesh.position.clone());
        }
        
        // Remove enemy from scene and array
        scene.remove(enemy.mesh);
        const index = enemies.indexOf(enemy);
        if (index > -1) {
            enemies.splice(index, 1);
        }
        
        // Check if all enemies are defeated
        if (enemies.length === 0) {
            // Spawn next wave
            setTimeout(() => {
                if (gameState.active) {
                    spawnEnemyWave();
                }
            }, 3000);
        }
    }
    
    function createAmmoPickup(position) {
        // Create ammo pickup
        const pickupGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.8);
        const pickupMaterial = new THREE.MeshStandardMaterial({ color: 0xffaa00 });
        const pickup = new THREE.Mesh(pickupGeometry, pickupMaterial);
        
        pickup.position.copy(position);
        pickup.position.y = 0.5; // Slightly above ground
        
        scene.add(pickup);
        
        // Add to pickups array
        pickups.push({
            mesh: pickup,
            type: 'ammo',
            amount: 10 + Math.floor(Math.random() * 20),
            created: Date.now()
        });
        
        // Make it rotate
        pickup.userData.rotationSpeed = 0.03;
        
        // Make it bob up and down
        pickup.userData.bobHeight = 0.5;
        pickup.userData.bobSpeed = 0.005;
        pickup.userData.bobOffset = Math.random() * Math.PI * 2;
    }
    
    function updateEnemies() {
        for (let i = 0; i < enemies.length; i++) {
            const enemy = enemies[i];
            
            // Move towards player
            const direction = new THREE.Vector3();
            direction.subVectors(player.position, enemy.mesh.position).normalize();
            
            // Check for obstacles
            const raycaster = new THREE.Raycaster(
                enemy.mesh.position,
                direction,
                0,
                2
            );
            
            const obstacles = scene.children.filter(obj => obj.userData.isObstacle);
            const intersects = raycaster.intersectObjects(obstacles);
            
            if (intersects.length === 0) {
                // No obstacles, move directly towards player
                enemy.mesh.position.x += direction.x * enemy.speed;
                enemy.mesh.position.z += direction.z * enemy.speed;
            } else {
                // Obstacle detected, try to move around it
                const perpDirection = new THREE.Vector3(-direction.z, 0, direction.x);
                
                // Check left or right movement
                const leftRaycaster = new THREE.Raycaster(
                    enemy.mesh.position,
                    perpDirection,
                    0,
                    2
                );
                
                const rightRaycaster = new THREE.Raycaster(
                    enemy.mesh.position,
                    perpDirection.clone().negate(),
                    0,
                    2
                );
                
                const leftIntersects = leftRaycaster.intersectObjects(obstacles);
                const rightIntersects = rightRaycaster.intersectObjects(obstacles);
                
                if (leftIntersects.length === 0 || (rightIntersects.length > 0 && leftIntersects[0].distance > rightIntersects[0].distance)) {
                    // Move left
                    enemy.mesh.position.x += perpDirection.x * enemy.speed * 0.7;
                    enemy.mesh.position.z += perpDirection.z * enemy.speed * 0.7;
                } else {
                    // Move right
                    enemy.mesh.position.x -= perpDirection.x * enemy.speed * 0.7;
                    enemy.mesh.position.z -= perpDirection.z * enemy.speed * 0.7;
                }
            }
            
            // Make sure enemy is on the ground
            enemy.mesh.position.y = enemy.size / 2;
            
            // Check distance to player
            const distanceToPlayer = enemy.mesh.position.distanceTo(player.position);
            
            if (distanceToPlayer < 2) {
                // Attack player if close enough
                const now = Date.now();
                if (now - enemy.lastAttack > 1000) { // Attack once per second
                    damagePlayer(settings.enemyDamage);
                    enemy.lastAttack = now;
                }
            }
            
            // Face towards player
            enemy.mesh.lookAt(player.position);
        }
    }
    
    function updateBullets() {
        const bulletSpeed = 1;
        const maxDistance = 100;
        const bulletLifetime = 1000; // 1 second max lifetime
        
        for (let i = bullets.length - 1; i >= 0; i--) {
            const bullet = bullets[i];
            
            // Move bullet forward
            bullet.mesh.position.add(bullet.direction.clone().multiplyScalar(bulletSpeed));
            bullet.distance += bulletSpeed;
            
            // Check if bullet should be removed
            const now = Date.now();
            if (bullet.distance > maxDistance || now - bullet.created > bulletLifetime) {
                scene.remove(bullet.mesh);
                bullets.splice(i, 1);
            }
        }
    }
    
    function updatePickups() {
        for (let i = pickups.length - 1; i >= 0; i--) {
            const pickup = pickups[i];
            
            // Make pickups rotate
            if (pickup.mesh.userData.rotationSpeed) {
                pickup.mesh.rotation.y += pickup.mesh.userData.rotationSpeed;
            }
            
            // Make pickups bob up and down
            if (pickup.mesh.userData.bobHeight) {
                const bobOffset = pickup.mesh.userData.bobOffset || 0;
                const time = Date.now() * pickup.mesh.userData.bobSpeed;
                pickup.mesh.position.y = 0.5 + Math.sin(time + bobOffset) * 0.2;
            }
            
            // Check if player is close to pickup
            const distanceToPlayer = pickup.mesh.position.distanceTo(player.position);
            
            if (distanceToPlayer < 2) {
                // Collect pickup
                if (pickup.type === 'ammo') {
                    gameState.reserveAmmo = Math.min(gameState.maxReserveAmmo, gameState.reserveAmmo + pickup.amount);
                    updateHUD();
                }
                
                // Remove pickup
                scene.remove(pickup.mesh);
                pickups.splice(i, 1);
            }
            
            // Remove old pickups
            const pickupLifetime = 20000; // 20 seconds
            const now = Date.now();
            if (now - pickup.created > pickupLifetime) {
                scene.remove(pickup.mesh);
                pickups.splice(i, 1);
            }
        }
    }
    
    function damagePlayer(damage) {
        gameState.health -= damage;
        
        // Show damage indicator
        damageIndicator.style.opacity = 0.7;
        damageIndicator.style.border = '5px solid rgba(255, 0, 0, 0.5)';
        
        setTimeout(() => {
            damageIndicator.style.opacity = 0;
            damageIndicator.style.border = '0px solid rgba(255, 0, 0, 0.5)';
        }, 300);
        
        // Update HUD
        updateHUD();
        
        // Check for game over
        if (gameState.health <= 0) {
            gameOver();
        }
    }
    
    function gameOver() {
        gameState.active = false;
        gameState.over = true;
        
        // Show game over screen
        gameOverScreen.style.display = 'flex';
        finalScoreText.textContent = `Final Score: ${gameState.score}`;
        
        // Release pointer lock
        document.exitPointerLock();
    }
    
    function pauseGame() {
        gameState.paused = true;
        
        // Show pause menu or instructions to click to resume
        const pauseMessage = document.createElement('div');
        pauseMessage.id = 'pause-message';
        pauseMessage.style.position = 'absolute';
        pauseMessage.style.top = '50%';
        pauseMessage.style.left = '50%';
        pauseMessage.style.transform = 'translate(-50%, -50%)';
        pauseMessage.style.color = '#ffffff';
        pauseMessage.style.fontSize = '24px';
        pauseMessage.style.textAlign = 'center';
        pauseMessage.textContent = 'Game Paused\nClick to Resume';
        document.body.appendChild(pauseMessage);
        
        // Click to resume
        document.addEventListener('click', resumeGame);
    }
    
    function resumeGame() {
        // Remove pause event listener
        document.removeEventListener('click', resumeGame);
        
        // Remove pause message
        const pauseMessage = document.getElementById('pause-message');
        if (pauseMessage) {
            pauseMessage.remove();
        }
        
        // Resume game
        gameState.paused = false;
        
        // Lock pointer again
        renderer.domElement.requestPointerLock();
    }
    
    function resetGame() {
        // Clear existing game elements
        while (scene.children.length > 0) {
            scene.remove(scene.children[0]);
        }
        
        // Reset game state
        gameState.started = false;
        gameState.active = false;
        gameState.paused = false;
        gameState.over = false;
        gameState.score = 0;
        gameState.wave = 1;
        gameState.enemiesKilled = 0;
        gameState.health = 100;
        gameState.ammo = 30;
        gameState.reserveAmmo = 90;
        gameState.reloading = false;
        
        // Clear arrays
        enemies = [];
        bullets = [];
        pickups = [];
        
        // Reset movement flags
        moveForward = false;
        moveBackward = false;
        moveLeft = false;
        moveRight = false;
        canJump = false;
        sprinting = false;
        
        // Start new game
        initGame();
    }
    
    function updateHUD() {
        // Update health bar
        const healthPercent = Math.max(0, gameState.health / gameState.maxHealth * 100);
        healthFill.style.width = `${healthPercent}%`;
        
        // Update ammo bar
        const ammoPercent = gameState.ammo / gameState.maxAmmo * 100;
        ammoFill.style.width = `${ammoPercent}%`;
        
        // Update ammo text
        if (!gameState.reloading) {
            ammoText.textContent = `Ammo: ${gameState.ammo}/${gameState.reserveAmmo}`;
        }
        
        // Update score
        scoreText.textContent = `Score: ${gameState.score}`;
    }
    
    function updatePlayerPosition() {
        if (!gameState.active || gameState.paused) return;
        
        const time = performance.now();
        const delta = (time - prevTime) / 1000;
        
        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;
        
        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize();
        
        // Calculate movement speed
        let movementSpeed = settings.playerSpeed;
        if (sprinting) {
            movementSpeed *= settings.sprintMultiplier;
        }
        
        if (moveForward || moveBackward) velocity.z -= direction.z * movementSpeed * delta * 100;
        if (moveLeft || moveRight) velocity.x -= direction.x * movementSpeed * delta * 100;
        
        // Update player position
        player.translateX(-velocity.x * delta);
        player.translateZ(-velocity.z * delta);
        
        // Keep camera aligned with player
        camera.position.x = player.position.x;
        camera.position.z = player.position.z;
        
        // Collision detection with obstacles
        const obstacles = scene.children.filter(obj => obj.userData.isObstacle);
        
        for (const obstacle of obstacles) {
            // Simple box collision
            const obstacleBox = new THREE.Box3().setFromObject(obstacle);
            
            // Create slightly smaller player box to prevent getting stuck
            const playerBox = new THREE.Box3();
            playerBox.min.set(
                player.position.x - 0.45,
                player.position.y - 1,
                player.position.z - 0.45
            );
            playerBox.max.set(
                player.position.x + 0.45,
                player.position.y + 1,
                player.position.z + 0.45
            );
            
            if (playerBox.intersectsBox(obstacleBox)) {
                // Move player away from obstacle
                const obstacleCenter = new THREE.Vector3();
                obstacleBox.getCenter(obstacleCenter);
                
                const direction = new THREE.Vector3();
                direction.subVectors(player.position, obstacleCenter).normalize();
                
                // Move player out of collision
                player.position.x += direction.x * 0.1;
                player.position.z += direction.z * 0.1;
                
                // Update camera position
                camera.position.x = player.position.x;
                camera.position.z = player.position.z;
            }
        }
        
        // Boundary checks to keep player within walls
        const boundary = 99;
        if (player.position.x > boundary) player.position.x = boundary;
        if (player.position.x < -boundary) player.position.x = -boundary;
        if (player.position.z > boundary) player.position.z = boundary;
        if (player.position.z < -boundary) player.position.z = -boundary;
        
        // Update camera position
        camera.position.x = player.position.x;
        camera.position.z = player.position.z;
        
        prevTime = time;
    }
    
    function animate() {
        requestAnimationFrame(animate);
        
        if (gameState.active && !gameState.paused) {
            // Update player position
            updatePlayerPosition();
            
            // Update enemies
            updateEnemies();
            
            // Update bullets
            updateBullets();
            
            // Update pickups
            updatePickups();
            
            // Weapon bob effect while moving
            if (moveForward || moveBackward || moveLeft || moveRight) {
                const bobAmount = 0.02;
                const bobSpeed = 10;
                weapon.position.y = Math.sin(performance.now() / bobSpeed * Math.PI) * bobAmount;
            }
        }
        
        // Render scene
        renderer.render(scene, camera);
    }
    </script>
</body>
</html>